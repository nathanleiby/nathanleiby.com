<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webaudio - timing</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.146.0/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      const DEBUG_MODE = false;
      let scene, camera, renderer, clock;

      const objects = [];

      const speed = 2.5;
      const height = 3;
      const offset = 0.5;
      const cameraSpeed = 0.2;
      const cameraXZdistance = 10;

      const defaultBallColor = 0xcccccc;

      function init() {
        const container = document.getElementById("container");

        scene = new THREE.Scene();

        clock = new THREE.Clock();

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          100
        );
        camera.position.set(cameraXZdistance, 3, cameraXZdistance);

        // lights

        const ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(0, 5, 5);
        scene.add(directionalLight);

        const d = 5;
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -d;
        directionalLight.shadow.camera.right = d;
        directionalLight.shadow.camera.top = d;
        directionalLight.shadow.camera.bottom = -d;

        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 20;

        directionalLight.shadow.mapSize.x = 1024;
        directionalLight.shadow.mapSize.y = 1024;

        // audio

        const audioLoader = new THREE.AudioLoader();

        const listener = new THREE.AudioListener();
        camera.add(listener);

        // floor

        const floorGeometry = new THREE.PlaneGeometry(10, 10);
        const floorMaterial = new THREE.MeshLambertMaterial({
          color: 0x4676b6,
        });

        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = Math.PI * -0.5;
        floor.receiveShadow = true;
        scene.add(floor);

        // objects

        const count = 5;
        const radius = 3;

        const ballGeometry = new THREE.SphereGeometry(0.3, 32, 16);
        ballGeometry.translate(0, 0.3, 0);

        // debugging helpers
        if (DEBUG_MODE) {
          const axesHelper = new THREE.AxesHelper(5);
          scene.add(axesHelper);
        }

        // create objects when audio buffer is loaded

        audioLoader.load("sounds/ping_pong.mp3", function (buffer) {
          for (let i = 0; i < count; i++) {
            const s = (i / count) * Math.PI * 2;

            const ballMaterial = new THREE.MeshLambertMaterial({
              color: defaultBallColor,
            });
            const ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.castShadow = true;
            ball.userData.down = false;

            ball.position.x = radius * Math.cos(s);
            ball.position.z = radius * Math.sin(s);

            const audio = new THREE.PositionalAudio(listener);
            audio.setBuffer(buffer);
            ball.add(audio);

            scene.add(ball);
            objects.push(ball);
          }

          animate();
        });

        //

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        //

        window.addEventListener("resize", onWindowResize);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        render();
      }

      function render() {
        const time = clock.getElapsedTime();

        const focusDurationSecs = 7;
        const focusTimer = clock.getElapsedTime() / focusDurationSecs;
        const focusOneIdx = Math.floor(Math.floor(focusTimer) % objects.length);
        const focusTwoIdx = Math.floor(Math.ceil(focusTimer) % objects.length);
        const focusWeight = focusTimer % 1; // 0 to 1

        const cameraX = Math.cos(time * cameraSpeed) * cameraXZdistance;
        const cameraY = 3;
        const cameraZ = Math.sin(time * cameraSpeed) * cameraXZdistance;
        camera.position.set(cameraX, cameraY, cameraZ);

        for (let i = 0; i < objects.length; i++) {
          const ball = objects[i];

          const previousHeight = ball.position.y;
          ball.position.y = Math.abs(
            Math.sin(i * offset + time * speed) * height
          );

          if (ball.position.y < previousHeight) {
            ball.userData.down = true;
          } else {
            if (ball.userData.down === true) {
              // ball changed direction from down to up

              const audio = ball.children[0];
              audio.play(); // play audio with perfect timing when ball hits the surface
              ball.userData.down = false;
            }
          }
        }

        objects.forEach((o) => o.material.color.setHex(defaultBallColor));
        const f1 = objects[focusOneIdx];
        const f2 = objects[focusTwoIdx];
        f1.material.color.setRGB(0.5, 0, 0);
        f2.material.color.setRGB(
          0,
          THREE.MathUtils.lerp(0.5, 1, 1 - Math.cos(focusWeight * Math.PI)),
          0
        );

        const newX = THREE.MathUtils.lerp(
          f1.position.x,
          f2.position.x,
          focusWeight
        );
        const newZ = THREE.MathUtils.lerp(
          f1.position.z,
          f2.position.z,
          focusWeight
        );

        camera.lookAt(newX, cameraY, newZ);

        renderer.render(scene, camera);
      }

      window.onload = init;
    </script>
  </body>
</html>
